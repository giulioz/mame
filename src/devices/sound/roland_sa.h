// license:BSD-3-Clause
// copyright-holders:giulioz
#ifndef MAME_SOUND_ROLAND_SA_H
#define MAME_SOUND_ROLAND_SA_H

#pragma once

class roland_sa_device : public device_t, public device_sound_interface
{
public:
  roland_sa_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock);

  auto int_callback() { return m_int_callback.bind(); }

  u8 read(offs_t offset);
  void write(offs_t offset, u8 data);

  void load_roms(uint8_t *ic5, uint8_t *ic6, uint8_t *ic7);
  void set_sr_mode(bool mode);

protected:
  // device_t implementation
  virtual void device_start() override;
  virtual void device_reset() override;

  // device_sound_interface implementation
  virtual void sound_stream_update(sound_stream &stream, std::vector<read_stream_view> const &inputs, std::vector<write_stream_view> &outputs) override;

private:
  static constexpr unsigned NUM_VOICES = 16;
  static constexpr unsigned PARTS_PER_VOICE = 10;

  // LUT for the address speed
  static constexpr uint32_t env_table[] = {
      0x000000, 0x000023, 0x000026, 0x000029, 0x00002d, 0x000031, 0x000036,
      0x00003b, 0x000040, 0x000046, 0x00004c, 0x000052, 0x00005a, 0x000062,
      0x00006c, 0x000076, 0x000080, 0x00008c, 0x000098, 0x0000a4, 0x0000b4,
      0x0000c4, 0x0000d8, 0x0000ec, 0x000104, 0x00011c, 0x000134, 0x00014c,
      0x00016c, 0x00018c, 0x0001b4, 0x0001dc, 0x000200, 0x000230, 0x000260,
      0x000290, 0x0002d0, 0x000310, 0x000360, 0x0003b0, 0x000400, 0x000460,
      0x0004c0, 0x000520, 0x0005a0, 0x000620, 0x0006c0, 0x000760, 0x000800,
      0x0008c0, 0x000980, 0x000a40, 0x000b40, 0x000c40, 0x000d80, 0x000ec0,
      0x001000, 0x001180, 0x001300, 0x001480, 0x001680, 0x001880, 0x001b00,
      0x001d80, 0x002000, 0x002300, 0x002600, 0x002900, 0x002d00, 0x003100,
      0x003600, 0x003b00, 0x004000, 0x004600, 0x004c00, 0x005200, 0x005a00,
      0x006200, 0x006c00, 0x007600, 0x008000, 0x008c00, 0x009800, 0x00a400,
      0x00b400, 0x00c400, 0x00d800, 0x00ec00, 0x010000, 0x011800, 0x013000,
      0x014800, 0x016800, 0x018800, 0x01b000, 0x01d800, 0x020000, 0x023000,
      0x026000, 0x029000, 0x02d000, 0x031000, 0x036000, 0x03b000, 0x040000,
      0x046000, 0x04c000, 0x052000, 0x05a000, 0x062000, 0x06c000, 0x076000,
      0x080000, 0x08c000, 0x098000, 0x0a4000, 0x0b4000, 0x0c4000, 0x0d8000,
      0x0ec000, 0x100000, 0x118000, 0x130000, 0x148000, 0x168000, 0x188000,
      0x1b0000, 0x1d8000, 0x000000, 0x1fffdc, 0x1fffd9, 0x1fffd6, 0x1fffd2,
      0x1fffce, 0x1fffc9, 0x1fffc4, 0x1fffbf, 0x1fffb9, 0x1fffb3, 0x1fffad,
      0x1fffa5, 0x1fff9d, 0x1fff93, 0x1fff89, 0x1fff7f, 0x1fff73, 0x1fff67,
      0x1fff5b, 0x1fff4b, 0x1fff3b, 0x1fff27, 0x1fff13, 0x1ffefb, 0x1ffee3,
      0x1ffecb, 0x1ffeb3, 0x1ffe93, 0x1ffe73, 0x1ffe4b, 0x1ffe23, 0x1ffdff,
      0x1ffdcf, 0x1ffd9f, 0x1ffd6f, 0x1ffd2f, 0x1ffcef, 0x1ffc9f, 0x1ffc4f,
      0x1ffbff, 0x1ffb9f, 0x1ffb3f, 0x1ffadf, 0x1ffa5f, 0x1ff9df, 0x1ff93f,
      0x1ff89f, 0x1ff7ff, 0x1ff73f, 0x1ff67f, 0x1ff5bf, 0x1ff4bf, 0x1ff3bf,
      0x1ff27f, 0x1ff13f, 0x1fefff, 0x1fee7f, 0x1fecff, 0x1feb7f, 0x1fe97f,
      0x1fe77f, 0x1fe4ff, 0x1fe27f, 0x1fdfff, 0x1fdcff, 0x1fd9ff, 0x1fd6ff,
      0x1fd2ff, 0x1fceff, 0x1fc9ff, 0x1fc4ff, 0x1fbfff, 0x1fb9ff, 0x1fb3ff,
      0x1fadff, 0x1fa5ff, 0x1f9dff, 0x1f93ff, 0x1f89ff, 0x1f7fff, 0x1f73ff,
      0x1f67ff, 0x1f5bff, 0x1f4bff, 0x1f3bff, 0x1f27ff, 0x1f13ff, 0x1effff,
      0x1ee7ff, 0x1ecfff, 0x1eb7ff, 0x1e97ff, 0x1e77ff, 0x1e4fff, 0x1e27ff,
      0x1dffff, 0x1dcfff, 0x1d9fff, 0x1d6fff, 0x1d2fff, 0x1cefff, 0x1c9fff,
      0x1c4fff, 0x1bffff, 0x1b9fff, 0x1b3fff, 0x1adfff, 0x1a5fff, 0x19dfff,
      0x193fff, 0x189fff, 0x17ffff, 0x173fff, 0x167fff, 0x15bfff, 0x14bfff,
      0x13bfff, 0x127fff, 0x113fff, 0x0fffff, 0x0e7fff, 0x0cffff, 0x0b7fff,
      0x097fff, 0x077fff, 0x04ffff, 0x027fff};

  // LUT for bits 5/6/7/8 of the subphase
  static constexpr uint16_t addr_table[] = {0x1e0, 0x080, 0x060, 0x04d, 0x040, 0x036, 0x02d, 0x026,
                                            0x020, 0x01b, 0x016, 0x011, 0x00d, 0x00a, 0x006, 0x003};

  uint16_t samples_exp[0x20000];
  bool samples_exp_sign[0x20000];
  uint16_t samples_delta[0x20000];
  bool samples_delta_sign[0x20000];

  uint32_t phase_exp_table[0x10000];
  uint16_t samples_exp_table[0x8000];

  struct SA_Part
  {
    uint32_t sub_phase;
    uint32_t env_value;
  };

  devcb_write_line m_int_callback;

  sound_stream *m_stream;             						 // stream handle
  SA_Part m_parts[NUM_VOICES][PARTS_PER_VOICE];    // channel memory
  uint8_t m_ctrl_mem[0x2000];											 // RAM IC12 (as the CPU writes it)
  uint8_t m_irq_id;																 // voice/part that triggered the IRQ
  bool m_irq_triggered;														 // if there is an IRQ currently waiting
  bool m_sr_mode;																	 // sample rate mode (true = 20 KHz, false = 32 KHz)
};

DECLARE_DEVICE_TYPE(ROLAND_SA, roland_sa_device)

#endif // MAME_SOUND_ROLAND_SA_H
